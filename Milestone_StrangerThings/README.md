This readme is a description of how the code provided performs. First three global variables are instantiated to keep track of the packetSize, how big the packet is, the packetByte, the number of bytes in the packet, and the data, the current data in the byte. in cfgRBG(void), pins 1.6, 2.1, and 2.4 are instantiated to output and use set/reset signal from output mode 3. In cfgTimerA0(void) and cfgTimerA1(void), the clocks are set up to be SMCLK (1MHz), counting in Up mode, divided by 4, and cleared. Next CCRs corresponding to those timers are instantiated to count to 255 and enable outmode 3. In cfgUART(void), pins 1.1 and 1.2 are set to RXD and TXD, respectively. Then the UART clock is set to SMCLK, and the baud rate is set to 9600. Then the UART reset is disabled and UART interupts for RXD are enabled. In main(void), the watchdog timer is stopped, and the methods are called to instantiate the different elements. Then the microcontroller is set to LPM0 and enables global interupts. Lastly, the interupt vector method is declared. This interupt triggers any time data is grabbed from RXD. Inside the method the global variable data stores the first byte of the recieved packet. Then it determines if the data is being grabbed for the first time and sets the packetByte and packetSize equal to the data. Then it checks to make sure if there is enough data to send to the next node. If so it trims the number to be correct. If the data isn't grabbed for the first time, it checks whether the data is red, green or blue. Depending on that value, it sets the corresponding CCR equal to the data. If those 4 cases arent met, it checks if it can send the data to the next node and sets the TX buffer equal to that data. Then at the end it decrements the packetByte so that the program moves onto the next byte in the packet. 
